From 6a397082128f1c751b560bcdc2163530d9262605 Mon Sep 17 00:00:00 2001
From: Joost Jager <joost.jager@gmail.com>
Date: Mon, 12 Feb 2018 16:04:57 +0100
Subject: [PATCH 1/3] Okuda changes

---
 .../software/qsgsoftwarerenderloop.cpp        | 58 +++++++++++++++++++
 .../software/qsgsoftwarerenderloop_p.h        | 13 ++++-
 .../qsgsoftwarethreadedrenderloop.cpp         | 10 ++--
 src/quick/scenegraph/qsgcontext.cpp           |  1 +
 4 files changed, 76 insertions(+), 6 deletions(-)

diff --git a/src/quick/scenegraph/adaptations/software/qsgsoftwarerenderloop.cpp b/src/quick/scenegraph/adaptations/software/qsgsoftwarerenderloop.cpp
index f5a41410e..3c11a4e44 100644
--- a/src/quick/scenegraph/adaptations/software/qsgsoftwarerenderloop.cpp
+++ b/src/quick/scenegraph/adaptations/software/qsgsoftwarerenderloop.cpp
@@ -58,6 +58,11 @@ QSGSoftwareRenderLoop::QSGSoftwareRenderLoop()
 {
     sg = new QSGSoftwareContext();
     rc = sg->createRenderContext();
+
+    m_anim = sg->createAnimationDriver(this);
+    connect(m_anim, &QAnimationDriver::started, this, &QSGSoftwareRenderLoop::onAnimationStarted);
+    connect(m_anim, &QAnimationDriver::stopped, this, &QSGSoftwareRenderLoop::onAnimationStopped);
+    m_anim->install();
 }
 
 QSGSoftwareRenderLoop::~QSGSoftwareRenderLoop()
@@ -66,11 +71,52 @@ QSGSoftwareRenderLoop::~QSGSoftwareRenderLoop()
     delete sg;
 }
 
+
+void QSGSoftwareRenderLoop::onAnimationStarted()
+{
+    // startOrStopAnimationTimer();
+
+    for (const WindowData &w : qAsConst(m_windows))
+        w.window->requestUpdate();
+}
+
+void QSGSoftwareRenderLoop::onAnimationStopped()
+{
+    // startOrStopAnimationTimer();
+}
+
+
+void QSGSoftwareRenderLoop::startOrStopAnimationTimer()
+{
+    // int exposedWindowCount = 0;
+    // const WindowData *exposed = nullptr;
+
+    // for (int i = 0; i < m_windows.size(); ++i) {
+    //     const WindowData &w(m_windows[i]);
+    //     if (w.window->isVisible() && w.window->isExposed()) {
+    //         ++exposedWindowCount;
+    //         exposed = &w;
+    //     }
+    // }
+
+    // if (animationTimer && (exposedWindowCount == 1 || !m_anim->isRunning())) {
+    //     killTimer(animationTimer);
+    //     animationTimer = 0;
+    //     // If animations are running, make sure we keep on animating
+    //     if (m_anim->isRunning())
+    //         exposed->window->requestUpdate();
+    // } else if (!animationTimer && exposedWindowCount != 1 && m_anim->isRunning()) {
+    //     animationTimer = startTimer(qsgrl_animation_interval());
+    // }
+}
+
+
 void QSGSoftwareRenderLoop::show(QQuickWindow *window)
 {
     WindowData data;
     data.updatePending = false;
     data.grabOnly = false;
+    data.window = window;
     m_windows[window] = data;
 
     if (m_backingStores[window] == nullptr) {
@@ -203,6 +249,12 @@ void QSGSoftwareRenderLoop::renderWindow(QQuickWindow *window, bool isNewExpose)
         lastFrameTime = QTime::currentTime();
     }
 
+    if (m_anim->isRunning()) {
+        m_anim->advance();
+        window->requestUpdate();
+    }
+        
+    
     // Might have been set during syncSceneGraph()
     if (data.updatePending)
         maybeUpdate(window);
@@ -271,6 +323,12 @@ void QSGSoftwareRenderLoop::handleUpdateRequest(QQuickWindow *window)
     renderWindow(window);
 }
 
+QAnimationDriver *QSGSoftwareRenderLoop::animationDriver() const
+{
+    return m_anim;
+}
+
+
 QT_END_NAMESPACE
 
 #include "moc_qsgsoftwarerenderloop_p.cpp"
diff --git a/src/quick/scenegraph/adaptations/software/qsgsoftwarerenderloop_p.h b/src/quick/scenegraph/adaptations/software/qsgsoftwarerenderloop_p.h
index c724d1829..c64b8be5c 100644
--- a/src/quick/scenegraph/adaptations/software/qsgsoftwarerenderloop_p.h
+++ b/src/quick/scenegraph/adaptations/software/qsgsoftwarerenderloop_p.h
@@ -81,12 +81,13 @@ public:
 
     QSurface::SurfaceType windowSurfaceType() const override;
 
-    QAnimationDriver *animationDriver() const override { return 0; }
+    QAnimationDriver *animationDriver() const override;
 
     QSGContext *sceneGraphContext() const override;
     QSGRenderContext *createRenderContext(QSGContext *) const override { return rc; }
 
     struct WindowData {
+        QQuickWindow *window;
         bool updatePending : 1;
         bool grabOnly : 1;
     };
@@ -98,6 +99,16 @@ public:
     QSGRenderContext *rc;
 
     QImage grabContent;
+
+    QAnimationDriver *m_anim;
+
+
+public Q_SLOTS:
+    void onAnimationStarted();
+    void onAnimationStopped();
+
+private:
+    void startOrStopAnimationTimer();
 };
 
 QT_END_NAMESPACE
diff --git a/src/quick/scenegraph/adaptations/software/qsgsoftwarethreadedrenderloop.cpp b/src/quick/scenegraph/adaptations/software/qsgsoftwarethreadedrenderloop.cpp
index f8973af2f..fbad2c918 100644
--- a/src/quick/scenegraph/adaptations/software/qsgsoftwarethreadedrenderloop.cpp
+++ b/src/quick/scenegraph/adaptations/software/qsgsoftwarethreadedrenderloop.cpp
@@ -521,11 +521,11 @@ void QSGSoftwareRenderThread::syncAndRender()
 
         // Since there is no V-Sync with QBackingStore, throttle rendering the refresh
         // rate of the current screen the window is on.
-        int blockTime = vsyncDelta - (int) renderThrottleTimer.elapsed();
-        if (blockTime > 0) {
-            qCDebug(QSG_RASTER_LOG_RENDERLOOP, "RT - blocking for %d ms", blockTime);
-            msleep(blockTime);
-        }
+        //int blockTime = vsyncDelta - (int) renderThrottleTimer.elapsed();
+        //if (blockTime > 0) {
+        //    qCDebug(QSG_RASTER_LOG_RENDERLOOP, "RT - blocking for %d ms", blockTime);
+        //    msleep(blockTime);
+        //}
         renderThrottleTimer.restart();
 
         wd->fireFrameSwapped();
diff --git a/src/quick/scenegraph/qsgcontext.cpp b/src/quick/scenegraph/qsgcontext.cpp
index d9ed25c09..b9ecd357b 100644
--- a/src/quick/scenegraph/qsgcontext.cpp
+++ b/src/quick/scenegraph/qsgcontext.cpp
@@ -129,6 +129,7 @@ public:
     {
         QScreen *screen = QGuiApplication::primaryScreen();
         if (screen && !qsg_useConsistentTiming()) {
+            // If refresh rate isn't reported properly, think about hard coding it here
             m_vsync = 1000.0 / screen->refreshRate();
             if (m_vsync <= 0)
                 m_mode = TimerMode;
-- 
2.17.1

